# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ejxMctO32z9Bx7OhNBz-J3Z7Z98zOS5Z
"""

import streamlit as st
import torch
import torch.nn as nn
import numpy as np
import os

# --- 1. PyTorch Generator Model Definition (MUST MATCH your training script's Generator) ---
# This class definition is crucial for loading the .pth state_dict
class Generator(nn.Module):
    def __init__(self, noise_dim, num_classes, img_shape=(1, 28, 28)):
        super().__init__()
        self.noise_dim = noise_dim
        self.num_classes = num_classes
        self.img_shape = img_shape

        self.label_embedding = nn.Embedding(num_classes, num_classes)

        self.main = nn.Sequential(
            nn.Linear(noise_dim + num_classes, 256 * 7 * 7),
            nn.BatchNorm1d(256 * 7 * 7),
            nn.LeakyReLU(0.2, inplace=True),
            nn.Unflatten(1, (256, 7, 7)),

            nn.ConvTranspose2d(256, 128, kernel_size=4, stride=2, padding=1, bias=False),
            nn.BatchNorm2d(128),
            nn.LeakyReLU(0.2, inplace=True),

            nn.ConvTranspose2d(128, 64, kernel_size=4, stride=2, padding=1, bias=False),
            nn.BatchNorm2d(64),
            nn.LeakyReLU(0.2, inplace=True),

            nn.Conv2d(64, img_shape[0], kernel_size=3, stride=1, padding=1, bias=False),
            nn.Tanh()
        )

    def forward(self, noise, labels):
        c = self.label_embedding(labels)
        z = torch.cat([noise, c], 1)
        img = self.main(z)
        return img

# --- 2. Model Loading ---
# Determine device to load model (CPU is safer for general deployment unless you configure GPU)
device = torch.device("cpu") # For Streamlit Cloud, CPU is generally default/recommended unless specific GPU setup.

@st.cache_resource # Cache the model to avoid reloading on every rerun
def load_pytorch_generator_model(noise_dim, num_classes):
    model_path = os.path.join(os.path.dirname(__file__), 'models', 'cgan_generator_model_pytorch.pth')
    if not os.path.exists(model_path):
        st.error(f"PyTorch model not found at: {model_path}. Please ensure 'cgan_generator_model_pytorch.pth' is in the 'models' directory.")
        return None
    try:
        model = Generator(noise_dim, num_classes).to(device)
        model.load_state_dict(torch.load(model_path, map_location=device))
        model.eval() # Set to evaluation mode for inference
        return model
    except Exception as e:
        st.error(f"Error loading PyTorch model: {e}")
        return None

# --- Model Parameters (Match your training script) ---
NOISE_DIM = 100
NUM_CLASSES = 10
IMG_SHAPE = (1, 28, 28)

generator = load_pytorch_generator_model(NOISE_DIM, NUM_CLASSES)

# --- 3. Streamlit UI ---
st.set_page_config(
    page_title="Handwritten Digit Image Generator (PyTorch)",
    page_icon="✍️",
    layout="centered"
)

st.title("Handwritten Digit Image Generator (PyTorch)")
st.write("Generate synthetic MNIST-like images using your trained PyTorch model.")

if generator is None:
    st.warning("Generator model could not be loaded. Please check the model path and ensure it's saved correctly.")
else:
    # User input for digit selection
    digit_choice = st.selectbox(
        "Choose a digit to generate (0-9):",
        list(range(NUM_CLASSES)),
        index=0 # Default to digit 0
    )

    # Button to trigger generation
    if st.button("Generate Images", help="Click to generate 5 images of the selected digit"):
        st.subheader(f"Generated images of digit {digit_choice}")

        num_images_to_generate = 5

        try:
            # Generate random noise and labels as PyTorch tensors
            noise = torch.randn(num_images_to_generate, NOISE_DIM, device=device)
            labels = torch.full((num_images_to_generate,), digit_choice, dtype=torch.long, device=device)

            # Generate images using the loaded generator
            with torch.no_grad(): # Disable gradient calculation for inference
                generated_images = generator(noise, labels).cpu() # Move to CPU for numpy conversion

            # Post-process generated images: scale from [-1, 1] to [0, 255] and convert to NumPy
            generated_images = (generated_images + 1) / 2.0 * 255.0
            # Permute dimensions from (N, C, H, W) to (N, H, W, C) for display
            generated_images = generated_images.permute(0, 2, 3, 1).numpy().astype(np.uint8)

            # Display the 5 images in columns
            cols = st.columns(num_images_to_generate)
            for i, col in enumerate(cols):
                with col:
                    # For grayscale, select the first (and only) channel
                    st.image(generated_images[i, :, :, 0], caption=f"Sample {i+1}", width=100)

        except Exception as e:
            st.error(f"An error occurred during image generation: {e}")
            st.info("Please ensure your PyTorch generator model's input shapes are correct and it's trained for conditional generation.")

st.markdown("---")
st.markdown("Powered by Streamlit and a trained PyTorch Conditional GAN model.")
